<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>RCTF2019 baby_crypto & baby_aes - rmb122's notebook</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="密码学只做出来两题 baby, 暗示我还是学密码学的 baby (逃"><meta property="og:image" content><meta property="og:title" content="RCTF2019 baby_crypto & baby_aes"><meta property="og:description" content="密码学只做出来两题 baby, 暗示我还是学密码学的 baby (逃"><meta property="og:type" content="article"><meta property="og:url" content="https://rmb122.com/2019/05/22/RCTF2019-baby-crypto-baby-aes-Writeup/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-05-22T17:51:21+00:00"><meta property="article:modified_time" content="2019-05-22T17:51:21+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="RCTF2019 baby_crypto & baby_aes"><meta name=twitter:description content="密码学只做出来两题 baby, 暗示我还是学密码学的 baby (逃"><script src=https://rmb122.com/js/feather.min.js></script>
<link rel=stylesheet type=text/css media=screen href=https://rmb122.com/css/main.21410c161c7e5bcadc5a4eccf49ce5a024e0e8fc19babbd534cfe87972f5ee51.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://rmb122.com/css/dark.726cd11ca6eb7c4f7d48eb420354f814e5c1b94281aaf8fd0511c1319f7f78a4.css disabled></head><body><div class=content><header><div class=main><a href=https://rmb122.com/>rmb122's notebook</a></div><nav><a href=/>首页</a>&nbsp;
<a href=/posts>归档</a>&nbsp;
<a href=/tags>标签</a>&nbsp;
<a href=/links>友链</a>&nbsp;
<a href=/about>关于</a>
| <a id=dark-mode-toggle onclick=toggleTheme() href></a>
<script src=https://rmb122.com/js/themetoggle.js></script></nav></header><main><article><div class=title><h1 class=title>RCTF2019 baby_crypto & baby_aes</h1><div class=meta>发表于 2019 年 5 月 22 日</div></div><section class=body><p>密码学只做出来两题 baby, 暗示我还是学密码学的 baby (逃</p><h2 id=baby_crypto>baby_crypto</h2><p>这题还算比较常规, 主要逻辑如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>while</span> <span style=color:#ff79c6>True</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;Input your cookie:&#34;</span>)
</span></span><span style=display:flex><span>        data_hex <span style=color:#ff79c6>=</span> sys<span style=color:#ff79c6>.</span>stdin<span style=color:#ff79c6>.</span>readline()<span style=color:#ff79c6>.</span>strip()
</span></span><span style=display:flex><span>        data <span style=color:#ff79c6>=</span> binascii<span style=color:#ff79c6>.</span>unhexlify(data_hex)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>assert</span>(<span style=color:#8be9fd;font-style:italic>len</span>(data) <span style=color:#ff79c6>&gt;</span> iv_len <span style=color:#ff79c6>+</span> hash_len)
</span></span><span style=display:flex><span>        iv, cookie_padded_encrypted, hv <span style=color:#ff79c6>=</span> data[:iv_len], data[iv_len: <span style=color:#ff79c6>-</span>hash_len], data[<span style=color:#ff79c6>-</span>hash_len:]
</span></span><span style=display:flex><span>        cipher <span style=color:#ff79c6>=</span> Cipher(algorithms<span style=color:#ff79c6>.</span>AES(key), modes<span style=color:#ff79c6>.</span>CBC(iv), backend<span style=color:#ff79c6>=</span>backend)
</span></span><span style=display:flex><span>        decryptor <span style=color:#ff79c6>=</span> cipher<span style=color:#ff79c6>.</span>decryptor()
</span></span><span style=display:flex><span>        cookie_padded <span style=color:#ff79c6>=</span> decryptor<span style=color:#ff79c6>.</span>update(cookie_padded_encrypted) <span style=color:#ff79c6>+</span> decryptor<span style=color:#ff79c6>.</span>finalize()
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>try</span>:
</span></span><span style=display:flex><span>            cookie <span style=color:#ff79c6>=</span> unpad(cookie_padded)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>except</span> Exception <span style=color:#ff79c6>as</span> e:
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;Invalid padding&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>continue</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>not</span> is_valid_hash(cookie, hv):
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;Invalid hash&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>continue</span>
</span></span><span style=display:flex><span>        info <span style=color:#ff79c6>=</span> {}
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> _ <span style=color:#ff79c6>in</span> cookie<span style=color:#ff79c6>.</span>split(<span style=color:#f1fa8c>b</span><span style=color:#f1fa8c>&#34;;&#34;</span>):
</span></span><span style=display:flex><span>            k, v <span style=color:#ff79c6>=</span> _<span style=color:#ff79c6>.</span>split(<span style=color:#f1fa8c>b</span><span style=color:#f1fa8c>&#34;:&#34;</span>)
</span></span><span style=display:flex><span>            info[k] <span style=color:#ff79c6>=</span> v
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> info[<span style=color:#f1fa8c>b</span><span style=color:#f1fa8c>&#34;admin&#34;</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>b</span><span style=color:#f1fa8c>&#34;1&#34;</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>with</span> <span style=color:#8be9fd;font-style:italic>open</span>(<span style=color:#f1fa8c>&#34;flag&#34;</span>) <span style=color:#ff79c6>as</span> f:
</span></span><span style=display:flex><span>                flag <span style=color:#ff79c6>=</span> f<span style=color:#ff79c6>.</span>read()
</span></span><span style=display:flex><span>                <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;Your flag: </span><span style=color:#f1fa8c>%s</span><span style=color:#f1fa8c>&#34;</span> <span style=color:#ff79c6>%</span>flag)
</span></span></code></pre></div><p>很明显的看到可以 <code>padding oracle</code>, 只要满足 <code>info[b"admin"] == b"1"</code> 就可以拿到 <code>flag</code>,
但在 <code>cookie</code> 后面设置了 hash 来效验 <code>cookie</code> 的有效性, 但是没有检测重复的键值
所以这里可以结合长度扩展攻击, 我们假设 <code>cookie</code> 为 <code>admin:0;username:abcde;password:abcde</code>
我们可以在原 <code>cookie</code> 后面添加一个 <code>;admin:1</code>, 得到
<code>admin:0;username:abcde;password:abcde\x80\x00\x00\x00\x00\x00\x00\x00\x00\x01\xa8;admin:1</code>,
因为顺序的关系, 这将覆盖之前的值, 从而满足条件. 脚本如下
一开始没有国内的服务器, 写完下午睡了一觉起来才跑完 233</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> remotecli <span style=color:#6272a4># https://github.com/rmb122/remoteCLI</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> hashpumpy
</span></span><span style=display:flex><span><span style=color:#ff79c6>from</span> binascii <span style=color:#ff79c6>import</span> hexlify, unhexlify
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> copy
</span></span><span style=display:flex><span><span style=color:#ff79c6>from</span> tqdm <span style=color:#ff79c6>import</span> tqdm
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>padding</span>(byte):
</span></span><span style=display:flex><span>    padlen <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>16</span> <span style=color:#ff79c6>-</span> <span style=color:#8be9fd;font-style:italic>len</span>(byte) <span style=color:#ff79c6>%</span> <span style=color:#bd93f9>16</span>
</span></span><span style=display:flex><span>    byte <span style=color:#ff79c6>+=</span> <span style=color:#8be9fd;font-style:italic>bytearray</span>([padlen] <span style=color:#ff79c6>*</span> padlen)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> byte
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>addIvLastByte</span>(iv, currIndex, midval):
</span></span><span style=display:flex><span>    target <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>16</span> <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span> <span style=color:#ff79c6>-</span> currIndex
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>range</span>(currIndex, <span style=color:#bd93f9>16</span>):
</span></span><span style=display:flex><span>        iv[i] <span style=color:#ff79c6>=</span> midval[i] <span style=color:#ff79c6>^</span> target
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> iv
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>xor</span>(a, b):
</span></span><span style=display:flex><span>    result <span style=color:#ff79c6>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>range</span>(<span style=color:#8be9fd;font-style:italic>len</span>(a)):
</span></span><span style=display:flex><span>        result<span style=color:#ff79c6>.</span>append(a[i] <span style=color:#ff79c6>^</span> b[i])
</span></span><span style=display:flex><span>    result <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>bytearray</span>(result)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> result
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cli <span style=color:#ff79c6>=</span> remotecli<span style=color:#ff79c6>.</span>CLI()
</span></span><span style=display:flex><span>cli<span style=color:#ff79c6>.</span>connect(<span style=color:#f1fa8c>&#39;207.148.68.109&#39;</span>, <span style=color:#bd93f9>20000</span>)
</span></span><span style=display:flex><span>cli<span style=color:#ff79c6>.</span>sendLine(<span style=color:#f1fa8c>&#39;abcde&#39;</span>)
</span></span><span style=display:flex><span>cli<span style=color:#ff79c6>.</span>sendLine(<span style=color:#f1fa8c>&#39;abcde&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hv_hex_len <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>40</span>
</span></span><span style=display:flex><span>iv_len <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>16</span>
</span></span><span style=display:flex><span>orgCookie <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#39;admin:0;username:abcde;password:abcde&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cookie <span style=color:#ff79c6>=</span> cli<span style=color:#ff79c6>.</span>recvLinesUntilHave(<span style=color:#f1fa8c>&#39;Input your cookie:&#39;</span>)[<span style=color:#ff79c6>-</span><span style=color:#bd93f9>2</span>]
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(cookie)
</span></span><span style=display:flex><span>hv_hex <span style=color:#ff79c6>=</span> cookie[<span style=color:#ff79c6>-</span>hv_hex_len:]
</span></span><span style=display:flex><span>iv <span style=color:#ff79c6>=</span> cookie[:iv_len]
</span></span><span style=display:flex><span>cookieEnc <span style=color:#ff79c6>=</span> cookie[iv_len: <span style=color:#ff79c6>-</span> hv_hex_len]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fakeHash, fakeCookie <span style=color:#ff79c6>=</span> hashpumpy<span style=color:#ff79c6>.</span>hashpump(hv_hex, orgCookie, <span style=color:#f1fa8c>&#39;;admin:1&#39;</span>, iv_len)
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(fakeCookie)
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(fakeHash)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fakeHash <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>bytearray</span>(unhexlify(fakeHash))
</span></span><span style=display:flex><span>fakeCookie <span style=color:#ff79c6>=</span> padding(fakeCookie)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>assert</span> <span style=color:#8be9fd;font-style:italic>len</span>(fakeCookie) <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>64</span>
</span></span><span style=display:flex><span>dummy <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>bytearray</span>([<span style=color:#bd93f9>0</span> <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>range</span>(<span style=color:#8be9fd;font-style:italic>len</span>(fakeCookie) <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>16</span>)]) <span style=color:#6272a4># iv + cookie</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span> pos <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>range</span>(<span style=color:#bd93f9>64</span> <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>16</span>, <span style=color:#bd93f9>16</span>, <span style=color:#ff79c6>-</span>iv_len):
</span></span><span style=display:flex><span>    curr <span style=color:#ff79c6>=</span> dummy[pos <span style=color:#ff79c6>-</span> iv_len:pos]
</span></span><span style=display:flex><span>    iv <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>bytearray</span>([<span style=color:#bd93f9>0</span> <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>range</span>(iv_len)])
</span></span><span style=display:flex><span>    midval <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>bytearray</span>([<span style=color:#bd93f9>0</span> <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>range</span>(iv_len)])
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> currIndex <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>range</span>(<span style=color:#bd93f9>0</span>, iv_len)[::<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>]:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>in</span> tqdm(<span style=color:#8be9fd;font-style:italic>range</span>(<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>256</span>)):
</span></span><span style=display:flex><span>            iv[currIndex] <span style=color:#ff79c6>=</span> i
</span></span><span style=display:flex><span>            cli<span style=color:#ff79c6>.</span>sendLine(hexlify(iv <span style=color:#ff79c6>+</span> curr <span style=color:#ff79c6>+</span> fakeHash))
</span></span><span style=display:flex><span>            res <span style=color:#ff79c6>=</span> cli<span style=color:#ff79c6>.</span>recvline()
</span></span><span style=display:flex><span>            <span style=color:#6272a4>#print(res)</span>
</span></span><span style=display:flex><span>            cli<span style=color:#ff79c6>.</span>recvline()
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> <span style=color:#f1fa8c>&#34;Invalid padding&#34;</span> <span style=color:#ff79c6>not</span> <span style=color:#ff79c6>in</span> res:
</span></span><span style=display:flex><span>                midval[currIndex] <span style=color:#ff79c6>=</span> (<span style=color:#bd93f9>16</span> <span style=color:#ff79c6>-</span> currIndex) <span style=color:#ff79c6>^</span> iv[currIndex]
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> currIndex <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>:
</span></span><span style=display:flex><span>                    tmp <span style=color:#ff79c6>=</span> xor(midval, fakeCookie[pos<span style=color:#ff79c6>-</span>iv_len<span style=color:#ff79c6>*</span><span style=color:#bd93f9>2</span>:pos<span style=color:#ff79c6>-</span>iv_len])
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>for</span> tmpPos <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>range</span>(<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>16</span>):
</span></span><span style=display:flex><span>                        dummy[pos<span style=color:#ff79c6>-</span>iv_len<span style=color:#ff79c6>*</span><span style=color:#bd93f9>2</span> <span style=color:#ff79c6>+</span> tmpPos] <span style=color:#ff79c6>=</span> tmp[tmpPos]
</span></span><span style=display:flex><span>                iv <span style=color:#ff79c6>=</span> addIvLastByte(iv, currIndex, midval)
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>break</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cli<span style=color:#ff79c6>.</span>sendLine(hexlify(dummy <span style=color:#ff79c6>+</span> fakeHash))
</span></span><span style=display:flex><span>cli<span style=color:#ff79c6>.</span>console()
</span></span></code></pre></div><h2 id=baby_aes>baby_aes</h2><p>这题比较有意思, 操作还是比较硬核的, 主要逻辑</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    K <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>b</span><span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>\x01\x23\x45\x67\x89\xab\xcd\xef\xfe\xdc\xba\x98\x76\x54\x32\x10</span><span style=color:#f1fa8c>&#34;</span>
</span></span><span style=display:flex><span>    Ke <span style=color:#ff79c6>=</span> init(K)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    backend <span style=color:#ff79c6>=</span> default_backend()
</span></span><span style=display:flex><span>    key <span style=color:#ff79c6>=</span> os<span style=color:#ff79c6>.</span>urandom(<span style=color:#bd93f9>16</span>)
</span></span><span style=display:flex><span>    iv <span style=color:#ff79c6>=</span> encrypt(key, Ke)
</span></span><span style=display:flex><span>    cipher <span style=color:#ff79c6>=</span> Cipher(algorithms<span style=color:#ff79c6>.</span>AES(key), modes<span style=color:#ff79c6>.</span>CBC(iv), backend<span style=color:#ff79c6>=</span>backend)
</span></span><span style=display:flex><span>    decryptor <span style=color:#ff79c6>=</span> cipher<span style=color:#ff79c6>.</span>decryptor()
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;Input a hexstr to decrypt:&#34;</span>)
</span></span><span style=display:flex><span>        data <span style=color:#ff79c6>=</span> sys<span style=color:#ff79c6>.</span>stdin<span style=color:#ff79c6>.</span>readline()<span style=color:#ff79c6>.</span>strip()
</span></span><span style=display:flex><span>        ciphertext <span style=color:#ff79c6>=</span> binascii<span style=color:#ff79c6>.</span>unhexlify(data)
</span></span><span style=display:flex><span>        plaintext <span style=color:#ff79c6>=</span> decryptor<span style=color:#ff79c6>.</span>update(ciphertext) <span style=color:#ff79c6>+</span> decryptor<span style=color:#ff79c6>.</span>finalize()
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;Decrypted result:&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>print</span>(binascii<span style=color:#ff79c6>.</span>hexlify(plaintext)<span style=color:#ff79c6>.</span>decode())
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>except</span> Exception <span style=color:#ff79c6>as</span> e:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>with</span> <span style=color:#8be9fd;font-style:italic>open</span>(<span style=color:#f1fa8c>&#34;flag&#34;</span>, <span style=color:#f1fa8c>&#39;rb&#39;</span>) <span style=color:#ff79c6>as</span> f:
</span></span><span style=display:flex><span>        flag <span style=color:#ff79c6>=</span> f<span style=color:#ff79c6>.</span>read()
</span></span><span style=display:flex><span>        padder <span style=color:#ff79c6>=</span> padding<span style=color:#ff79c6>.</span>PKCS7(<span style=color:#bd93f9>128</span>)<span style=color:#ff79c6>.</span>padder()
</span></span><span style=display:flex><span>        flag_padded <span style=color:#ff79c6>=</span> padder<span style=color:#ff79c6>.</span>update(flag) <span style=color:#ff79c6>+</span> padder<span style=color:#ff79c6>.</span>finalize()
</span></span><span style=display:flex><span>        encryptor <span style=color:#ff79c6>=</span> cipher<span style=color:#ff79c6>.</span>encryptor()
</span></span><span style=display:flex><span>        flag_encrypted <span style=color:#ff79c6>=</span> encryptor<span style=color:#ff79c6>.</span>update(flag_padded) <span style=color:#ff79c6>+</span> encryptor<span style=color:#ff79c6>.</span>finalize()
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;Your encrypted flag is:&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>print</span>(binascii<span style=color:#ff79c6>.</span>hexlify(flag_encrypted)<span style=color:#ff79c6>.</span>decode())
</span></span></code></pre></div><p>其中 <code>init</code> 函数是 AES 秘钥扩展, <code>encrypt</code> 是 AES 轮函数, 但是改变了 AES 原来的常数, 这两个函数也是本题的核心, 我们留到后面讲. 这里假设我们已经写出对应的解密函数,</p><p>看到 <code>iv = encrypt(key, Ke)</code>, 可以看到 iv 就是 key 的加密, 只要我们能获得 <code>iv</code>, 就能解密出 <code>key</code>, 从而解密得到 <code>flag</code>.</p><p>注意到这里是用 AES 解密输入的数据, 结合 CBC 模式</p><p><img src=https://i.loli.net/2019/05/19/5ce17ac53478934702.png alt=CBC></p><p>我们可以输入两个相同分块(b1 + b1&rsquo;)长度的数据, 其中解密结果的第二块(o2)是这样算出来的
<code>xor(AESdec(b1'), b1) = o2</code>
而 <code>o2</code>, <code>b1</code> 都是已知的, 我们就可以解出 <code>AESdec(b1)</code>, 因为我们输入的两个分块相同,
我们将 <code>AESdec(b1)</code> 与 <code>o1</code> xor 一下, 就能得到 <code>iv</code>, 这时只要用 <code>K</code> 解密 <code>iv</code> 就能得到 <code>key</code>
从而解密 <code>flag</code>.</p><p>但问题就是这里出题人魔改了 AES, 不能直接解密, 这里最好自己写过一遍 AES 的实现, 否则接下来有些部分可能不太方便,
首先可以搜到作者魔改的<a href=https://github.com/ricmoo/pyaes/blob/master/pyaes/aes.py>原代码</a>
可以看到 Sbox, T1-4 都被修改, 并且没有给出对应的逆变换</p><p><code>S = [0x63, 0x7c, 0x77, 0x7....</code> &lt;-原来的
<code>S = [0x93 ,0x43 ,0x5D ,0x6....</code> &lt;-魔改之后的</p><p>但是从 <code>rcon = [....0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91 ]</code> 这最后几个
数据可以看出, 仍然还是在 <code>GF(2^8) mod x^8 + x^4 + x^3 + x + 1</code> 上的, 否则 0xc5 * 2 不会等于 0x91</p><p>所以这里应该只是单纯的改了 Sbox, 不是改其他常数带来的副作用.</p><p>接下来可以看到 T 被完全修改了, 首先了解一下 T 变换是干嘛的,
这里借一张图说明
<img src=https://i.loli.net/2019/05/22/5ce5502037ede37184.png alt></p><p>注: ShiftRow 与 ByteSub 之间的顺序不敏感, 可以在进入变换之前就 ShiftRow 好, 就跟上图一样, 取的不是原矩阵的一行, 而是 ShiftRow 之后矩阵的一行</p><p>T 变换是结合了 ByteSub MixColumn, 将 AES 轮函数中的两步并到一起, 加速效率的一种方法, 如果按照原来的矩阵乘法
<img src=https://i.loli.net/2019/05/22/5ce551bb6234249389.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>d0 = 2 * ByteSub(b0) + 3 * ByteSub(b1) + 1 * ByteSub(b2) + 1 * ByteSub(b3)
</span></span><span style=display:flex><span>d1 = 1 * ByteSub(b0) + 2 * ByteSub(b1) + 3 * ByteSub(b2) + 1 * ByteSub(b3)
</span></span><span style=display:flex><span>d2 = 1 * ByteSub(b0) + 1 * ByteSub(b1) + 2 * ByteSub(b2) + 3 * ByteSub(b3)
</span></span><span style=display:flex><span>d3 = 3 * ByteSub(b0) + 1 * ByteSub(b1) + 1 * ByteSub(b2) + 2 * ByteSub(b3)
</span></span></code></pre></div><p>算起来非常的麻烦, 但是看到</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>2 * ByteSub(b0)
</span></span><span style=display:flex><span>1 * ByteSub(b0)
</span></span><span style=display:flex><span>1 * ByteSub(b0)
</span></span><span style=display:flex><span>3 * ByteSub(b0)
</span></span></code></pre></div><p>可以想到这结构完全是固定的, 因为加密的是字节, 定义域是 0-255, 完全可以将 0-255 的值带入 b0, 将所有值提前算出, 并成 4 个字节, 在使用时查表就行, 大大提高效率. 因为 GF(2^8) 上的加法实际上就是 xor, 所以</p><p><code>MixColumn(ByteSub(b0 b1 b2 b3)) = T1[b0] xor T2[b1] xor T3[b2] xor T4[b3]</code></p><p>在本题中, 假设进入轮函数之前 state 全是 0, 那么这里查表可以直接一步到位 <code>T1[0] ^ T2[0] ^ T3[0] ^ T4[0] = 0xaeaeaeae</code>, 而按照原列混合的矩阵算等于 <code>0x93939393</code> 说明列混合的矩阵也被修改, 这就比较麻烦了, 需要用一下 <code>sage</code>.</p><p>因为假设输入轮函数的 state 全是 0， 那么 subByte 的得到的是 0x93, 而 <code>T[0] = 0xF467D4E9</code>, 原 AES 的因数是 <code>(2, 3, 1, 1)</code>, 这里我们假设魔改之后的是 <code>(cofe[0], cofe[1], cofe[2], cofe[3])</code></p><p>按照上面 T 变换的定义, <code>T[0]</code> 是这么来的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>cofe[0] * b0
</span></span><span style=display:flex><span>cofe[3] * b0
</span></span><span style=display:flex><span>cofe[2] * b0
</span></span><span style=display:flex><span>cofe[1] * b0
</span></span></code></pre></div><p>而本题 <code>T[0] = 0xF467D4E9</code> 可以写出
<code>0x93 * cofe[0] = 0xF4</code>, <code>0x93 * cofe[3] = 0x67</code>, <code>0x93 * cofe[2] = 0xD4</code>, <code>0x93 * cofe[1] = 0xE9</code>,
在 0-255 的范围内爆破下,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>sage: F.&lt;x&gt; = GF(2^8, modulus=[1,1,0,1,1,0,0,0,1])
</span></span><span style=display:flex><span>sage: F.modulus()
</span></span><span style=display:flex><span>x^8 + x^4 + x^3 + x + 1
</span></span><span style=display:flex><span>sage: def f(num):
</span></span><span style=display:flex><span>....:     global F
</span></span><span style=display:flex><span>....:     return F.fetch_int(num)
</span></span><span style=display:flex><span>....:
</span></span><span style=display:flex><span>sage: for i in range(0,256):
</span></span><span style=display:flex><span>....:     if f(0x93)*f(i)==f(0xf4):
</span></span><span style=display:flex><span>....:         print(i)
</span></span><span style=display:flex><span>....:
</span></span><span style=display:flex><span>8
</span></span><span style=display:flex><span>sage: for i in range(0,256):
</span></span><span style=display:flex><span>....:     if f(0x93)*f(i)==f(0x67):
</span></span><span style=display:flex><span>....:         print(i)
</span></span><span style=display:flex><span>....:
</span></span><span style=display:flex><span>9
</span></span><span style=display:flex><span>sage: for i in range(0,256):
</span></span><span style=display:flex><span>....:     if f(0x93)*f(i)==f(0xd4):
</span></span><span style=display:flex><span>....:         print(i)
</span></span><span style=display:flex><span>....:
</span></span><span style=display:flex><span>7
</span></span><span style=display:flex><span>sage: for i in range(0,256):
</span></span><span style=display:flex><span>....:     if f(0x93)*f(i)==f(0xe9):
</span></span><span style=display:flex><span>....:         print(i)
</span></span><span style=display:flex><span>....:
</span></span><span style=display:flex><span>5
</span></span></code></pre></div><p>那么四个因数是 <code>(8, 5, 7, 9)</code>, 还原成矩阵求 GF(2^8) 上的逆矩阵, 再用一下 <code>sage</code>, 当然如果是大佬可以手算 _(:з」∠)_</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>sage: c = matrix(F, [[f(8), f(5), f(7), f(9)], [f(9), f(8), f(5), f(7)], [f(7), f(9), f(8), f(5)], [f(5), f(7), f(9), f(8)]])
</span></span><span style=display:flex><span>sage: c.inverse()
</span></span><span style=display:flex><span>[      x^7 + x^4 + x^2 + x           x^7 + x^6 + x^3       x^7 + x^4 + x^2 + 1 x^5 + x^4 + x^3 + x^2 + 1]
</span></span><span style=display:flex><span>[x^5 + x^4 + x^3 + x^2 + 1       x^7 + x^4 + x^2 + x           x^7 + x^6 + x^3       x^7 + x^4 + x^2 + 1]
</span></span><span style=display:flex><span>[      x^7 + x^4 + x^2 + 1 x^5 + x^4 + x^3 + x^2 + 1       x^7 + x^4 + x^2 + x           x^7 + x^6 + x^3]
</span></span><span style=display:flex><span>[          x^7 + x^6 + x^3       x^7 + x^4 + x^2 + 1 x^5 + x^4 + x^3 + x^2 + 1       x^7 + x^4 + x^2 + x]
</span></span></code></pre></div><p>转换回数字表示就是
<code>cofes = (150, 200, 149, 61)</code>
带进 invMixColumn 就可以正确解密啦, 如果没有自己写过的话, 可以参考我写的<a href=https://github.com/rmb122/Cryptography/blob/master/AES-128-CBC.py>辣鸡实现</a>
修改 <code>mixColumn</code> 和 <code>invMixColumn</code> 里面的 <code>polynomialMutil</code> 函数乘的数为矩阵对应位置的数就行了</p><p>既然现在可以解密, 按着上面的思路就能拿 <code>flag</code> 了~
接下来 nc 一下, 输入 16 个 1,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Input a hexstr to decrypt:
</span></span><span style=display:flex><span>3131313131313131313131313131313131313131313131313131313131313131
</span></span><span style=display:flex><span>Decrypted result:
</span></span><span style=display:flex><span>3205fe135b595e72c90d2613ada3087812f10dee01e66c4d1e47089a0ff0f18c
</span></span><span style=display:flex><span>Your encrypted flag is:
</span></span><span style=display:flex><span>c2c06ee0e21dae7e5b64fcb84397b4ed920c28bb81a676d817a4b920564bd04dd2a570900ff2e9d5fee9cb74c37c4812
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>from</span> Crypto.Cipher <span style=color:#ff79c6>import</span> AES <span style=color:#ff79c6>as</span> stdAES
</span></span><span style=display:flex><span><span style=color:#ff79c6>from</span> Crypto.Util.strxor <span style=color:#ff79c6>import</span> strxor
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>K <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>b</span><span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>\x01\x23\x45\x67\x89\xab\xcd\xef\xfe\xdc\xba\x98\x76\x54\x32\x10</span><span style=color:#f1fa8c>&#34;</span>
</span></span><span style=display:flex><span>hexstr <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#39;11111111111111111111111111111111&#39;</span><span style=color:#ff79c6>.</span>encode()
</span></span><span style=display:flex><span>dec <span style=color:#ff79c6>=</span> unhexlify(<span style=color:#f1fa8c>&#39;3205fe135b595e72c90d2613ada3087812f10dee01e66c4d1e47089a0ff0f18c&#39;</span>)
</span></span><span style=display:flex><span>midVal <span style=color:#ff79c6>=</span> strxor(dec[<span style=color:#bd93f9>16</span>:<span style=color:#bd93f9>32</span>], hexstr[<span style=color:#bd93f9>0</span>:<span style=color:#bd93f9>16</span>])
</span></span><span style=display:flex><span>iv <span style=color:#ff79c6>=</span> strxor(dec[<span style=color:#bd93f9>0</span>:<span style=color:#bd93f9>16</span>], midVal)
</span></span><span style=display:flex><span>aes <span style=color:#ff79c6>=</span> AES()
</span></span><span style=display:flex><span>key <span style=color:#ff79c6>=</span> aes<span style=color:#ff79c6>.</span>decryptBlock(iv, K)
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(key)
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(iv)
</span></span><span style=display:flex><span>flag <span style=color:#ff79c6>=</span> unhexlify(<span style=color:#f1fa8c>&#39;c2c06ee0e21dae7e5b64fcb84397b4ed920c28bb81a676d817a4b920564bd04dd2a570900ff2e9d5fee9cb74c37c4812&#39;</span>)
</span></span><span style=display:flex><span>stdaes <span style=color:#ff79c6>=</span> stdAES<span style=color:#ff79c6>.</span>new(key, stdAES<span style=color:#ff79c6>.</span>MODE_CBC, iv)
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(stdaes<span style=color:#ff79c6>.</span>decrypt(flag))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#39;&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>b&#39;N</span><span style=color:#f1fa8c>\t\x9c\xce</span><span style=color:#f1fa8c>*</span><span style=color:#f1fa8c>\xfa\xc1\x02\x94\xd1\x02\xf2\xb8</span><span style=color:#f1fa8c>d*E&#39;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>b&#39;</span><span style=color:#f1fa8c>\x11\xc5\xc2\xcc</span><span style=color:#f1fa8c>k</span><span style=color:#f1fa8c>\x8e\x03\x0e\xe6</span><span style=color:#f1fa8c>{</span><span style=color:#f1fa8c>\x1f\xb8\x93</span><span style=color:#f1fa8c>b</span><span style=color:#f1fa8c>\xc8\xc5</span><span style=color:#f1fa8c>&#39;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>b&#39;RCTF{88358abe-e571-4bdf-95a3-93e9d8ddf558}</span><span style=color:#f1fa8c>\x06\x06\x06\x06\x06\x06</span><span style=color:#f1fa8c>&#39;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>&#39;&#39;&#39;</span>
</span></span></code></pre></div><p>这样子求解, 比直接爆破四个因数优雅很多, 而且之后遇到类似题目, 修改列混合的因数, 可以直接按照上面的方法通杀</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/crypto>crypto</a></li><li><a href=/tags/writeup>writeup</a></li></ul></nav></div></article></main><footer><div class=footer-info>2022 @rmb122</div><div style=display:flex><a class=border></a><a class=soc href=https://github.com/rmb122 title=GitHub><i data-feather=github></i></a></div></footer><script>feather.replace()</script></div></body></html>