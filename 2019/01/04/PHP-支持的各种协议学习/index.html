<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>PHP 支持的各种协议学习 - rmb122's notebook</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="PHP 支持了不少协议, 特别是其中的 php:// 和 phar:// 经常能在意想不到的地方发挥意想不到的作用 233. 之前都是花式百度, 这次系统学习一下. 所有的协议都可以在官网上找到.
这些协议一般配合 file_get_contents, include 使用, 部分情况下受到 php.ini 里面的 allow_url_fopen(默认开启) 和 allow_url_include(默认关闭) 限制. 如果 allow_url_include 开启的话, 是非常危险的, 可能存在远程文件包含."><meta property="og:image" content><meta property="og:title" content="PHP 支持的各种协议学习"><meta property="og:description" content="PHP 支持了不少协议, 特别是其中的 php:// 和 phar:// 经常能在意想不到的地方发挥意想不到的作用 233. 之前都是花式百度, 这次系统学习一下. 所有的协议都可以在官网上找到.
这些协议一般配合 file_get_contents, include 使用, 部分情况下受到 php.ini 里面的 allow_url_fopen(默认开启) 和 allow_url_include(默认关闭) 限制. 如果 allow_url_include 开启的话, 是非常危险的, 可能存在远程文件包含."><meta property="og:type" content="article"><meta property="og:url" content="https://rmb122.com/2019/01/04/PHP-%E6%94%AF%E6%8C%81%E7%9A%84%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-01-04T18:27:17+00:00"><meta property="article:modified_time" content="2019-01-04T18:27:17+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="PHP 支持的各种协议学习"><meta name=twitter:description content="PHP 支持了不少协议, 特别是其中的 php:// 和 phar:// 经常能在意想不到的地方发挥意想不到的作用 233. 之前都是花式百度, 这次系统学习一下. 所有的协议都可以在官网上找到.
这些协议一般配合 file_get_contents, include 使用, 部分情况下受到 php.ini 里面的 allow_url_fopen(默认开启) 和 allow_url_include(默认关闭) 限制. 如果 allow_url_include 开启的话, 是非常危险的, 可能存在远程文件包含."><script src=https://rmb122.com/js/feather.min.js></script>
<link rel=stylesheet type=text/css media=screen href=https://rmb122.com/css/main.15a3e00bd789260e70f3c566b00eddd5fd9c8ce9ef09dd0484e02575cccf5006.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://rmb122.com/css/dark.cefce3efc3d1673a12499d1730c46db6951ef16bde19558cdb583fa050acc62e.css disabled></head><body><div class=content><header><div class=main><a href=https://rmb122.com/>rmb122's notebook</a></div><nav><a href=/>首页</a>&nbsp;
<a href=/posts>归档</a>&nbsp;
<a href=/tags>标签</a>&nbsp;
<a href=/links>友链</a>&nbsp;
<a href=/about>关于</a>
| <a id=dark-mode-toggle onclick=toggleTheme() href></a>
<script src=https://rmb122.com/js/themetoggle.js></script></nav></header><main><article><div class=title><h1 class=title>PHP 支持的各种协议学习</h1><div class=meta>发表于 2019 年 1 月 4 日</div></div><section class=body><p>PHP 支持了不少协议, 特别是其中的 <code>php://</code> 和 <code>phar://</code> 经常能在意想不到的地方发挥意想不到的作用 233. 之前都是花式百度, 这次系统学习一下. 所有的协议都可以在<a href=http://php.net/manual/en/wrappers.php>官网</a>上找到.</p><p>这些协议一般配合 <code>file_get_contents</code>, <code>include</code> 使用, 部分情况下受到 php.ini 里面的 <code>allow_url_fopen</code>(默认开启) 和 <code>allow_url_include</code>(默认关闭) 限制. 如果 <code>allow_url_include</code> 开启的话, 是非常危险的, 可能存在远程文件包含.</p><h3 id=0x01-file>0x01 file://</h3><p>不受 <code>allow_url</code> 限制, 用来读取文件, 一般不会用到, 毕竟 file_get_contents 和 include 本身就是这个功能 233.</p><p>而且 file:// 必须跟着绝对路径, 比如 file:///etc/passwd, file://../../../etc/passwd 是不行的</p><h3 id=0x02-http>0x02 http://</h3><p>受到 <code>allow_url</code> 限制. 这个就是 http 协议啦, 也就是说 file_get_contents 可以当 curl 用, 不过比较麻烦就是了, 像这样的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#8be9fd;font-style:italic>$file</span> <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>$_GET</span>[<span style=color:#f1fa8c>&#39;file&#39;</span>];
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#ff79c6>if</span>(file_get_contents(<span style=color:#8be9fd;font-style:italic>$file</span>) <span style=color:#ff79c6>===</span> <span style=color:#f1fa8c>&#34;The quick brown fox jumps over a lazy dog.&#34;</span>) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>    <span style=color:#ff79c6>echo</span> <span style=color:#8be9fd;font-style:italic>$flag</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>}
</span></span></code></pre></div><p>就可以在自己服务器上写个内容是 <code>The quick brown fox jumps over a lazy dog.</code> 的 html, 然后 <code>file=http://xxxx.xxx/xx.html</code> 就可以了, 当然后面还有更简单的绕过方法.</p><h3 id=0x03-ftp>0x03 ftp://</h3><p>比较鸡肋, 我试了一下, 开启了 ftp 扩展的情况下, php5, php7 都没用, 似乎已经被废弃了</p><h3 id=0x04-php>0x04 php://</h3><p>相对来说内容最多, 也是最重要的一个协议, 协议底下分了许多种流, 各个流分开看看. 需要注意的是这个协议也受到 <code>allow_url</code> 限制, 远程读取的流都不给 <code>include</code> 233</p><p><strong>@ php://stdin, php://stdout, php://stderr</strong></p><p>这个是拿来给命令行程序用的0.0 比如</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>&lt;?</span>php
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>file_put_contents(<span style=color:#f1fa8c>&#34;php://stdout&#34;</span>, file_get_contents(<span style=color:#f1fa8c>&#34;php://stdin&#34;</span>));
</span></span></code></pre></div><p>就是将从 stdin 里面的数据输出到 stdout 里面去</p><p><strong>@ php://input</strong></p><p>对任何 HTTP method 都可以用, 读取 HTTP body 里面的内容, 用来读二进制文件的 POST 有奇效, 也可以用来绕过上面的例子</p><p><strong>@ php://output</strong></p><p>官网上解释的很清楚233, 跟 echo, print 一样, 命令行就输出到 stdout, cgi 就输出到 html 里面</p><p><strong>@ php://memory and php://temp</strong></p><p>可以拿来存东西, 但是感觉很鸡肋, 因为在 fd 关闭之后就直接清空了, 233 真的是只能拿来临时存放东西</p><p><strong>@ php://filter</strong></p><p>最骚的东西, 可以用于读取源码, 比如</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>include</span> <span style=color:#8be9fd;font-style:italic>$_GET</span>[<span style=color:#f1fa8c>&#39;file&#39;</span>]<span style=color:#ff79c6>.</span><span style=color:#f1fa8c>&#34;.php&#34;</span>;
</span></span></code></pre></div><p>本来其实没有什么大问题, 但是如果 file 是 <code>php://filter/read=convert.base64-encode/resource=index</code> 读取出来的内容将 base64encode, 从而直接显示出来, 可以通过这种方式来读取 <code>.php</code> 文件.</p><p>注意过滤器是可以叠加的, 可以这样 <code>php://filter/read=convert.base64-encode/read=convert.base64-encode/resource=index.php</code> base64两次.</p><p>PS. read= 可以省略, 也就是说可以写成 <code>php://filter/convert.base64-encode/resource=index</code></p><p>过滤器除了 <code>convert.base64-encode</code> 还有很多, 可以看<a href=http://php.net/manual/zh/filters.php>这里</a></p><p>这些流也可以拿来写入文件, 比如</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>file_put_contents(<span style=color:#f1fa8c>&#34;php://filter/write=convert.base64-encode/resource=index.php&#34;</span>, <span style=color:#f1fa8c>&#34;test&#34;</span>); <span style=color:#6272a4>// 同样 write= 可以省略
</span></span></span></code></pre></div><p>index.php 中写入的将是 base64 编码过后的 test, 也就是 dGVzdA==</p><p>最后, resource 后面还可以跟其他协议, 甚至可以 <code>resource=php://</code> 这样嵌套, 不过 <code>allow_url</code> 限制不会因此改变. 如果是 include 调用的, 依然受到 <code>allow_url_include</code> 限制.</p><h3 id=0x05-compresszlib-compressbzip2-zip>0x05 compress.zlib://, compress.bzip2://, zip://</h3><p>不受 <code>allow_url</code> 限制, 而且 zip:// 只要符合 zip 格式即可, 不用在意后缀名, 所以在可以上传文件而且可以包含这个文件的情况下, 可以拿来任意代码执行. 用法是 <code>zip://path_to_zipfile#filename_in_zip</code>, 注意在地址栏传参的时候记得把 <code>#</code> 换成 <code>%23</code>, 不然会被当成锚点.</p><p>比如 <code>include $_GET['file'].".php";</code> 的情况下, 可以上传图片. 就可以将一个含有马的 zip 文件重名成 jpg 后缀上传, 最后 <code>file=zip://upload/xxx.jpg%23backdoor</code> 即可.</p><p>另外, compress.bzip2:// 和 compress.zlib:// 对于没有压缩的文件是直接读取原文的, 而且不像 file://, 是支持相对路径的, 可以当做强化版来用, 233 在 <code>parse_url</code> 之后检测 host 的情况下可能有奇效, 比如 <code>compress.bzip2://www.baidu.com/../../../../../../etc/passwd</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>php <span style=color:#ff79c6>&gt;</span> print_r(parse_url(<span style=color:#f1fa8c>&#39;compress.bzip2://www.baidu.com/../../../../../../etc/passwd&#39;</span>));
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#ff79c6>Array</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>(
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>    [scheme] <span style=color:#ff79c6>=&gt;</span> compress<span style=color:#ff79c6>.</span>bzip2
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>    [host] <span style=color:#ff79c6>=&gt;</span> www<span style=color:#ff79c6>.</span>baidu<span style=color:#ff79c6>.</span>com
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>    [path] <span style=color:#ff79c6>=&gt;</span> <span style=color:#ff79c6>/../../../../../../</span>etc<span style=color:#ff79c6>/</span>passwd
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span>)
</span></span></code></pre></div><h3 id=0x06-data><strong>0</strong>x06 data://</h3><p>就和官网上讲的一样 233, <a href=http://www.faqs.org/rfcs/rfc2397.html>RFC2397</a> 的标准, 格式就是 <code>data:[&lt;mediatype>][;base64],&lt;data></code>, 你可以在浏览器上输入 data://test,data schema test, 也可以看到浏览器其实也是支持这个协议的, 一般用来通过 html 直接传输图片.</p><p>比较可惜的是受到 <code>allow_url</code> 限制, 不过因为 <code>allow_url_fopen</code> 是默认开启的, 拿来构造任意内容还是可以的, 拿来绕上面的例子也是很轻松.</p><h3 id=0x07-phar>0x07 phar://</h3><p>比较逆天的存在, 不受 <code>allow_url</code> 限制</p><ol><li>可以这样, phar://test.zip/index.php 代替上面的 zip:// 的作用 (同样不受后缀名影响)</li><li>通过 phar pack -f test.phar bd.php 生成的 phar 包来包含 phar 里面的内容 (同样不受后缀名影响)</li><li>当然最最最骚的是<a href=https://blog.ripstech.com/2018/new-php-exploitation-technique/>这个</a>, 只要能上传文件到同一个服务器, 就能任意反序列化, 甚至 <code>file_exist</code> 这样的函数都会受到影响, 然后通过内部类来各种操作得到 flag. 可以说 2018 年的 CTF 竞赛不知道出现了多少遍这个东西 233, 就如文章所说, 真的是开创了一个新的 <code>technique</code>.</li></ol><p>其他的协议都不是 php 自带的, 需要安装插件, 就不看了 233</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/php>php</a></li><li><a href=/tags/web>web</a></li></ul></nav></div></article></main><footer><div class=footer-info>2022 © rmb122</div><div style=display:flex><a class=border></a><a class=soc href=https://github.com/rmb122 title=GitHub><i data-feather=github></i></a></div></footer><script>feather.replace()</script></div></body></html>