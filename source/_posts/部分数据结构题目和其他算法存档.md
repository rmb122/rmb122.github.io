---
title: "部分数据结构题目和其他算法存档"
date: 2018-03-04 16:37:19
tags: [cpp, leetcode]
---

存个档~

<!-- more -->

#### 1.求一个集合的幂集

```cpp
void getPowerSetEx(std::vector<int> &set, std::vector<std::vector<int>> &result, std::vector<int> last, unsigned int pos) {
	if (pos < set.size()) {  //PS: 这里的last表示的是上一次的意思_(:3」∠)_
		for (unsigned int i = 0; i < set.size() - pos; ++i) {
			std::vector<int> temp = last;
			temp.push_back(set[pos + i]);
			result.push_back(temp);
			getPowerSetEx(set, result, temp, pos + i + 1);
		}			
	}	
}

std::vector<std::vector<int>> getPowerSet(std::vector<int> set) {
	std::vector<std::vector<int>> result;
	result.push_back({}); //空集
	getPowerSetEx(set, result, {}, 0);
	return result;
}
```

#### 2.背包问题

设有ｎ个物品, 其重量分别为w1, w2, w3, …, wn, 所有物品的重量之和≥背包所能放置的重量Ｓ. 设计算法从中找出若干物品放入背包中, 使得其重量之和正好为Ｓ. 

```cpp
void getResult(std::vector<std::pair<int, int>> &items, std::vector<std::vector<std::pair<int, int>>> &result, int &weight, int &maxDepth, std::vector<std::pair<int, int>> last, unsigned int pos, int sum, int depth) {
	if (depth > maxDepth) {
		return;	
	}
	
	if (pos < items.size()) {
		for (unsigned int i = 0; i < items.size() - pos; ++i) {		
			int tempSum = sum + items[pos + i].second;
			if (tempSum > weight) { //如果此时已经比重量大了, 再往下试只会更大(所以要求数据从小到大排序)
				return;
			}
			std::vector<std::pair<int, int>> temp = last;
			temp.emplace_back(items[pos + i]);
			if (tempSum == weight) {
				result.push_back(temp);
			}
			getResult(items, result, weight, maxDepth, temp, pos + i + 1, tempSum, depth + 1);
		}
	}
}

bool compare(const std::pair<int, int> &a, const std::pair<int, int> &b) {
	if (a.second < b.second) {
		return true;
	}
	else {
		return false;
	}
}

std::vector<std::vector<std::pair<int, int>>> backPack(int s, int n, std::vector<int> items) {
	std::vector<std::pair<int, int>> itemCopy; //保存原来的位置信息
	for (unsigned int i = 0; i < items.size(); ++i) {
		itemCopy.emplace_back(i + 1, items[i]);
	}

	std::vector<std::vector<std::pair<int, int>>> result;
	std::sort(itemCopy.begin(), itemCopy.end(), compare); //按照从小到大排序

	getResult(itemCopy, result, s, n, {}, 0, 0, 0);
	return result;
}
```

#### 3.X皇后问题

```cpp
bool isVaild(int row, int col, vector<vector<int>> &checkerBoard) {
	for (int i = 0; i < row; ++i) {//检查纵向是否重复
		if (checkerBoard[i][col] == 1) {
			return false;
		}
	}
	for (int i = 0; i < col; ++i) {//检查左上方是否重复
		if (row - col + i >= 0 && checkerBoard[row - col + i][i] == 1) {
			return false;
		}
	}
	for (int i = 1; i < (checkerBoard.size() - col); ++i) {//检查右上方是否重复
		if (row - i >= 0 && checkerBoard[row - i][col + i] == 1) {
			return false;
		}
	}
	return true;
}

void queen(vector<vector<vector<int>>> &result, vector<vector<int>> lastCheckerBoard, int row) {
	if (row == lastCheckerBoard.size()) {
		result.push_back(lastCheckerBoard);
		return;
	}

	for (int i = 0; i < lastCheckerBoard.size(); ++i) {
		if (isVaild(row, i, lastCheckerBoard)) {
			vector<vector<int>> temp = lastCheckerBoard;
			temp[row][i] = 1;
			queen(result, temp, row + 1);
		}
	}
}

int printQueen()
{
	vector<vector<vector<int>>> result;
	vector<vector<int>> checkBoard(8, vector<int>(8, 0));
	queen(result, checkBoard, 0);

	int i = 1;
	for (auto borad : result) {
		cout << i << endl;
		++i;
		for (auto row : borad) {
			for (auto col : row) {
				if (col == 1) {
					cout << "■";
				}
				else{
					cout << "□";
				}
			}
			cout << endl;
		}
		cout << endl;
	}

    return 0;
}
```