---
title: "一题简单的逆向"
date: 2018-03-15 22:41:40
tags: [writeup, reverse]
---

第一次尝试看汇编, 因为以前玩过游戏 TIS-100, 所以感觉还不错.  题目: [http://ctf.nuptzj.cn/challenges#ReadAsm2](http://ctf.nuptzj.cn/challenges#ReadAsm2)

<!-- more -->

```c
int main(int argc, char const *argv[])
{
  char input[] = {0x0,  0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d,
                  0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b,
                  0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66 , 0x1c};
  func(input, 28);
  printf("%s\n",input+1);
  return 0;
}
```

看到这个, 很明显就是看懂func的汇编就行了.  大概意思是这样, 但真的不知道dl是哪里来的233

```x86asm
00000000004004e6 <func>:
  4004e6: 55                    push   rbp
  4004e7: 48 89 e5              mov    rbp,rsp
  4004ea: 48 89 7d e8           mov    QWORD PTR [rbp-0x18 //char *A ],rdi
  4004ee: 89 75 e4              mov    DWORD PTR [rbp-0x1c //B 循环次数],esi
  4004f1: c7 45 fc 01 00 00 00  mov    DWORD PTR [rbp-0x4 //C 计次],0x1 C=1
  4004f8: eb 28                 jmp    400522 <func+0x3c>
//
\* 4004fa: 8b 45 fc              mov    eax,DWORD PTR [rbp-0x4]
\* 4004fd: 48 63 d0              movsxd rdx,eax 
\* 400500: 48 8b 45 e8           mov    rax,QWORD PTR [rbp-0x18]
\* 400504: 48 01 d0              add    rax,rdx 
// 这段不知道有啥用

  400507: 8b 55 fc              mov    edx,DWORD PTR [rbp-0x4 //C]
  40050a: 48 63 ca              movsxd rcx,edx 
  40050d: 48 8b 55 e8           mov    rdx,QWORD PTR [rbp-0x18 //char *A]
  400511: 48 01 ca              add    rdx,rcx //C+A, rdx储存地址
  400514: 0f b6 0a              movzx  ecx,BYTE PTR [rdx] //解地址得到char A
  400517: 8b 55 fc              mov    edx,DWORD PTR [rbp-0x4]
  40051a: 31 ca                 xor    edx,ecx //C^*(C+A)
  40051c: 88 10                 mov    BYTE PTR [rax],dl //不知道这里dl哪来的, 感觉应该是edx. 总之意思是xor得到的值放回去. 
  40051e: 83 45 fc 01           add    DWORD PTR [rbp-0x4],0x1 //C++
  
  400522: 8b 45 fc              mov    eax,DWORD PTR [rbp-0x4]
  400525: 3b 45 e4              cmp    eax,DWORD PTR [rbp-0x1c] //C>B退出循环
  400528: 7e d0                 jle    4004fa <func+0x14>
  40052a: 90                    nop
  40052b: 5d                    pop    rbp
  40052c: c3                    ret
```

看懂以后翻译成高级语言 , 是这样, 相当照顾新手了. 

```c
void func(char* a, int b) {
	int c = 1;
	while (c <= b)
	{
		*(a + c) = c ^ *(a + c);
		c++;
	}
}
```

编译运行, 得到flag: flag{read\_asm\_is\_the\_basic}